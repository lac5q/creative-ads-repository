#!/usr/bin/env node
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
import express from "express";
import { detect } from "detect-port";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { TrieveSDK } from "trieve-ts-sdk";
import { z } from "zod";
class TransportManager {
  constructor() {
    this.transports = /* @__PURE__ */ new Map();
  }
  addTransport(transport, res) {
    const sessionId = transport.sessionId;
    this.transports.set(sessionId, transport);
    res.on("close", () => {
      this.removeTransport(sessionId);
    });
    return sessionId;
  }
  removeTransport(sessionId) {
    if (this.transports.has(sessionId)) {
      this.transports.delete(sessionId);
    }
  }
  getTransport(sessionId) {
    return this.transports.get(sessionId);
  }
  getAllTransports() {
    return Array.from(this.transports.values());
  }
}
const DEFAULT_PORT = 3001;
async function connectServer(server, useStdioTransport2) {
  if (useStdioTransport2) {
    console.log("Connecting to MCP server over stdio");
    const transport = new StdioServerTransport();
    await server.connect(transport);
    return;
  }
  const app = express();
  const port = await detect(DEFAULT_PORT);
  const transportManager = new TransportManager();
  app.use(express.json({ limit: "10mb" }));
  app.get("/sse", async (req, res) => {
    try {
      res.setHeader("Content-Type", "text/event-stream");
      res.setHeader("Cache-Control", "no-cache");
      res.setHeader("Connection", "keep-alive");
      const transport = new SSEServerTransport("/messages", res);
      const sessionId = transportManager.addTransport(transport, res);
      await server.connect(transport);
    } catch (error) {
      console.error("Error establishing SSE connection:", error);
      res.status(500).json({ error: "Failed to establish SSE connection" });
    }
  });
  app.post("/messages", async (req, res) => {
    const connectionId = req.query.sessionId;
    console.log("Connection ID", connectionId);
    if (!connectionId) {
      res.status(400).json({ error: "Missing connection ID param" });
      return;
    }
    const transport = transportManager.getTransport(connectionId);
    if (transport) {
      try {
        await transport.handlePostMessage(req, res, req.body);
      } catch (error) {
        console.error("Error handling POST message for connectionId:", connectionId, error);
        if (error instanceof Error && error.message.includes("connection closed")) {
          transportManager.removeTransport(connectionId);
        }
      }
    } else {
      res.status(404).json({ error: "Connection not found" });
    }
  });
  app.listen(port, () => {
    if (port !== DEFAULT_PORT) {
      console.error(`Port ${DEFAULT_PORT} is already in use. MCP Server running on SSE at http://localhost:${port}`);
    } else {
      console.error(`MCP Server running on SSE at http://localhost:${port}`);
    }
  });
  return app;
}
const SERVER_NAME = "@amp-labs/mcp-docs-server";
const SERVER_VERSION = "0.0.1";
function initialize() {
  console.error("Initializing MCP Server...");
  const server = new McpServer({
    name: SERVER_NAME,
    version: SERVER_VERSION
  });
  return server;
}
const SUBDOMAIN = "ampersand-24eb5c1a";
const SERVER_URL = "https://leaves.mintlify.com";
const DEFAULT_BASE_URL = "https://api.mintlifytrieve.com";
async function fetchSearchConfigurationAndOpenApi(subdomain) {
  try {
    const url = `${SERVER_URL}/api/mcp/config/${subdomain}`;
    const response = await fetch(url, { method: "GET" });
    if (!response.ok) {
      let msg = "";
      try {
        const json = await response.json();
        msg = json.error ?? String(response.status) + " " + response.statusText;
      } catch {
        msg = String(response.status) + " " + response.statusText;
      }
      throw new Error(`HTTP Error: ${msg}`);
    }
    const contentType = response.headers.get("content-type");
    if (!contentType || !contentType.includes("application/json")) {
      throw new Error("Response is not JSON");
    }
    return await response.json();
  } catch (error) {
    throw new Error("Failed to initialize: " + error);
  }
}
async function search(query, config) {
  const trieve = new TrieveSDK({
    apiKey: config.trieveApiKey,
    datasetId: config.trieveDatasetId,
    baseUrl: DEFAULT_BASE_URL
  });
  const data = await trieve.autocomplete({
    page_size: 10,
    query,
    search_type: "fulltext",
    extend_results: true,
    score_threshold: 1
  });
  if (data.chunks === void 0 || data.chunks.length === 0) {
    throw new Error("No results found");
  }
  return data.chunks.map((result) => {
    const chunk = result.chunk;
    return {
      title: chunk.metadata.title,
      content: chunk.chunk_html,
      link: chunk.link
    };
  });
}
async function createSearchTool(server) {
  const config = await fetchSearchConfigurationAndOpenApi(SUBDOMAIN);
  server.tool(
    "searchAmpersand",
    `Search across the Ampersand documentation to fetch relevant context for a given query related to integrations or using the Ampersand API or products.`,
    {
      query: z.string().describe(
        "The query to search for. The query could be anything related to the Ampersand documentation or API integrations in general, including (but not limited to):\n\n    Code examples\n\n    API references\n\n    Concepts and explanations\n\n    Troubleshooting steps\n\n    Best practices"
      )
    },
    async ({ query }) => {
      const results = await search(query, config);
      const content = results.map((result) => {
        const { title, content: content2, link } = result;
        const text = `Title: ${title}
Content: ${content2}
Link: ${link}`;
        return {
          type: "text",
          text
        };
      });
      return {
        content
      };
    }
  );
}
const args = process.argv.slice(2);
const useStdioTransport = args.includes("--transport") && args[args.indexOf("--transport") + 1] === "stdio";
async function main() {
  const server = initialize();
  await createSearchTool(server);
  const app = connectServer(server, useStdioTransport);
  return app;
}
let mcpApp = null;
try {
  mcpApp = main();
} catch (error) {
  console.error("Fatal error in trying to initialize MCP server: ", error);
  process.exit(1);
}
export {
  mcpApp
};
//# sourceMappingURL=index.js.map
